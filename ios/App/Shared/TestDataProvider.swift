/*
See LICENSE folder for this sampleâ€™s licensing information.

Abstract:
TestDataProvider protocol defines the interface for providing payload for Watch Connectivity APIs.
 Its extension provides default payload for the coomands.
*/

import UIKit

// Constants to access the payload dictionary.
// isCurrentComplicationInfo is to tell if the userInfo is from transferCurrentComplicationUserInfo
// in session:didReceiveUserInfo: (see SessionDelegater).
//
struct PayloadKey {
    static let timeStamp = "timeStamp"
    static let colorData = "colorData"
    static let isCurrentComplicationInfo = "isCurrentComplicationInfo"
}

// Constants to identify the app group container used for Settings-Watch.bundle and access
// the information in Settings-Watch.bundle.
//
struct WatchSettings {
    static let sharedContainerID = "" // Specify your group container ID here and Root.plist to make watch settings work.
    //static let sharedContainerID = "group.com.example.apple-samplecode.SimpleWatchConnectivity"
    static let useLogFileForFileTransfer = "useLogFileForFileTransfer"
    static let clearLogsAfterTransferred = "clearLogsAfterTransferred"
}

// Define the interfaces for providing payload for Watch Connectivity APIs.
// MainViewController and MainInterfaceController adopt this protocol.
//
protocol TestDataProvider {
    var appContext: [String: Any] { get }
    
    var message: [String: Any] { get }
    var messageData: Data { get }
    
    var userInfo: [String: Any] { get }
    
    var file: URL { get }
    var fileMetaData: [String: Any] { get }
}

// Generate default payload for commands, which contains a random color and a time stamp.
//
extension TestDataProvider {
    
    // Generate a dictionary containing a time stamp and a random color data.
    //
    private func timedColor() -> [String: Any] {
        let red = CGFloat(Float(arc4random()) / Float(UINT32_MAX))
        let green = CGFloat(Float(arc4random()) / Float(UINT32_MAX))
        let blue = CGFloat(Float(arc4random()) / Float(UINT32_MAX))
        
        let randomColor = UIColor(red: red, green: green, blue: blue, alpha: 1)
        
        let data = try? NSKeyedArchiver.archivedData(withRootObject: randomColor, requiringSecureCoding: false)
        guard let colorData = data else { fatalError("Failed to archive a UIColor!") }
    
        let dateFormatter = DateFormatter()
        dateFormatter.timeStyle = .medium
        let timeString = dateFormatter.string(from: Date())
        
        return [PayloadKey.timeStamp: timeString, PayloadKey.colorData: colorData]
    }
    
    // Generate an app context, used as the payload for updateApplicationContext.
    //
    var appContext: [String: Any] {
        return timedColor()
    }
    
    // Generate a message, used as the payload for sendMessage.
    //
    var message: [String: Any] {
        return timedColor()
    }
    
    // Generate a message, used as the payload for sendMessageData.
    //
    var messageData: Data {
        let data = try? NSKeyedArchiver.archivedData(withRootObject: timedColor(), requiringSecureCoding: false)
        guard let timedColor = data else { fatalError("Failed to archive a timedColor dictionary!") }
        return timedColor
    }
    
    // Generate a userInfo dictionary, used as the payload for transferUserInfo.
    //
    var userInfo: [String: Any] {
        return timedColor()
    }
    
    // Generate a file URL, used as the payload for transferFile.
    //
    // Use WatchSettings to choose the log file, which is generated by Logger
    // for debugging purpose, for file transfer from the watch side.
    // This is only for watchOS as the iOS app doesn't have WKBackgroundTask.
    //
    var file: URL {
        #if os(watchOS)
        if WatchSettings.sharedContainerID.isEmpty == false {
            let defaults = UserDefaults(suiteName: WatchSettings.sharedContainerID)
            if let enabled = defaults?.bool(forKey: WatchSettings.useLogFileForFileTransfer), enabled {
                return Logger.shared.getFileURL()
            }
        }
        #endif
        
        // Use Info.plist for file transfer.
        // Change this to a bigger file to make the file transfer progress more obvious.
        //
        guard let url = Bundle.main.url(forResource: "Info", withExtension: "plist") else {
            fatalError("Failed to find Info.plist in current bundle!")
        }
        return url
    }

    // Generate a file metadata dictionary, used as the payload for transferFile.
    //
    var fileMetaData: [String: Any] {
        return timedColor()
    }
    
    // Generate a complication info dictionary, used as the payload for transferCurrentComplicationUserInfo.
    //
    var currentComplicationInfo: [String: Any] {
        var complicationInfo = timedColor()
        complicationInfo[PayloadKey.isCurrentComplicationInfo] = true
        return complicationInfo
    }
}
